import jsPDF from 'jspdf';
import { Recipe } from '@/types/recipe';

export const generateRecipePDF = async (
  recipe: Recipe,
  userNotes?: string
): Promise<void> => {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'in',
    format: 'letter'
  });

  const pageWidth = 8.5;
  const pageHeight = 11;
  const margin = 0.75;
  const contentWidth = pageWidth - (2 * margin);
  let yPosition = margin;

  // Helper to add page break if needed
  const checkPageBreak = (neededSpace: number) => {
    if (yPosition + neededSpace > pageHeight - margin) {
      doc.addPage();
      yPosition = margin;
      return true;
    }
    return false;
  };

  // Header - QuickDish Branding
  doc.setFontSize(24);
  doc.setTextColor(4, 120, 87); // #047857 - dark green
  doc.text('QuickDish', margin, yPosition);
  yPosition += 0.4;

  // Recipe Title
  doc.setFontSize(20);
  doc.setTextColor(0, 0, 0);
  const titleLines = doc.splitTextToSize(recipe.name, contentWidth);
  doc.text(titleLines, margin, yPosition);
  yPosition += (titleLines.length * 0.3) + 0.3;

  // Recipe Image (if available)
  if (recipe.image) {
    try {
      checkPageBreak(2.5);
      const imgData = await loadImageAsBase64(recipe.image);
      const imgWidth = 3;
      const imgHeight = 2;
      doc.addImage(imgData, 'JPEG', margin, yPosition, imgWidth, imgHeight);
      yPosition += imgHeight + 0.3;
    } catch (error) {
      console.error('Failed to load image:', error);
    }
  }

  // Stats Section
  checkPageBreak(0.8);
  doc.setFontSize(12);
  doc.setTextColor(100, 100, 100);
  
  const stats = [
    `Servings: ${recipe.servings}`,
    `Prep: ${recipe.prepTime}`,
    `Cook: ${recipe.cookTime}`,
    `Difficulty: ${recipe.difficulty}`
  ];
  
  doc.text(stats.join(' | '), margin, yPosition);
  yPosition += 0.4;

  // Ingredients Section
  checkPageBreak(1);
  doc.setFontSize(16);
  doc.setTextColor(0, 0, 0);
  doc.text('Ingredients', margin, yPosition);
  yPosition += 0.3;

  doc.setFontSize(11);
  recipe.ingredients.forEach((ing) => {
    checkPageBreak(0.25);
    const parts = [ing.amount, ing.unit, ing.item].filter(Boolean).map(p => p.toString().trim());
    const ingredientText = `â€¢ ${parts.join(' ')}`;
    const lines = doc.splitTextToSize(ingredientText, contentWidth);
    doc.text(lines, margin, yPosition);
    yPosition += lines.length * 0.2 + 0.05;
  });

  yPosition += 0.3;

  // Instructions Section
  checkPageBreak(1);
  doc.setFontSize(16);
  doc.text('Instructions', margin, yPosition);
  yPosition += 0.3;

  doc.setFontSize(11);
  recipe.instructions.forEach((instruction, index) => {
    checkPageBreak(0.4);
    const stepText = `${index + 1}. ${instruction.replace(/\[|\]/g, '')}`;
    const lines = doc.splitTextToSize(stepText, contentWidth - 0.3);
    doc.text(lines, margin + 0.3, yPosition);
    yPosition += lines.length * 0.2 + 0.15;
  });

  // Personal Notes Section (if available)
  if (userNotes) {
    yPosition += 0.2;
    checkPageBreak(1);
    doc.setFontSize(16);
    doc.text('Your Notes', margin, yPosition);
    yPosition += 0.3;

    doc.setFontSize(11);
    doc.setTextColor(80, 80, 80);
    const notesLines = doc.splitTextToSize(userNotes, contentWidth);
    notesLines.forEach((line: string) => {
      checkPageBreak(0.25);
      doc.text(line, margin, yPosition);
      yPosition += 0.2;
    });
  }

  // Footer
  const totalPages = doc.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setTextColor(150, 150, 150);
    const currentDate = new Date().toLocaleDateString();
    const footerText = `Generated by QuickDish - ${currentDate}`;
    const textWidth = doc.getTextWidth(footerText);
    doc.text(footerText, (pageWidth - textWidth) / 2, pageHeight - 0.4);
  }

  // Sanitize filename
  const sanitizeFilename = (name: string): string => {
    return name
      .replace(/[^a-z0-9]/gi, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')
      .toLowerCase();
  };

  const filename = `QuickDish-${sanitizeFilename(recipe.name)}.pdf`;
  
  // For native apps, use Capacitor Share plugin to save PDF properly
  if (typeof window !== 'undefined') {
    try {
      // Check if we're in a Capacitor native app
      const isCapacitor = (window as any).Capacitor?.isNativePlatform?.() || false;
      
      if (isCapacitor) {
        // Use Capacitor Filesystem for native apps - write to Documents directory
        const { Filesystem, Directory } = await import('@capacitor/filesystem');
        const { Share } = await import('@capacitor/share');
        
        // Generate PDF as base64
        const pdfBase64 = doc.output('datauristring').split(',')[1];
        
        try {
          // Try to write to Documents directory (user-accessible on Android)
          const filePath = filename;
          await Filesystem.writeFile({
            path: filePath,
            data: pdfBase64,
            directory: Directory.Documents,
            recursive: true,
          });
          
          // Get file URI and share it
          const fileUri = await Filesystem.getUri({
            path: filePath,
            directory: Directory.Documents,
          });
          
          // Share the file (opens native share dialog where user can save/share)
          await Share.share({
            title: `Save ${recipe.name} Recipe`,
            text: `QuickDish Recipe: ${recipe.name}`,
            url: fileUri.uri,
            dialogTitle: 'Save Recipe PDF',
          });
        } catch (fsError) {
          // If Documents directory fails, try Cache and share
          console.error('Error writing to Documents:', fsError);
          const filePath = `QuickDish/${filename}`;
          await Filesystem.writeFile({
            path: filePath,
            data: pdfBase64,
            directory: Directory.Cache,
            recursive: true,
          });
          
          const fileUri = await Filesystem.getUri({
            path: filePath,
            directory: Directory.Cache,
          });
          
          await Share.share({
            title: `Save ${recipe.name} Recipe`,
            text: `QuickDish Recipe: ${recipe.name}`,
            url: fileUri.uri,
            dialogTitle: 'Save Recipe PDF',
          });
        }
        
        return;
      }
      
      // For web/mobile browsers, use blob download
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      if (isMobile) {
        // Generate blob and create download link for mobile
        const pdfBlob = doc.output('blob');
        const url = URL.createObjectURL(pdfBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } else {
        // Use standard save for desktop
        doc.save(filename);
      }
    } catch (error) {
      console.error('Error saving PDF:', error);
      // Fallback to blob method
      try {
        const pdfBlob = doc.output('blob');
        const url = URL.createObjectURL(pdfBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } catch (fallbackError) {
        console.error('Fallback PDF save also failed:', fallbackError);
        // Last resort - try direct save
        doc.save(filename);
      }
    }
  } else {
    // Fallback for non-browser environments
    doc.save(filename);
  }
};

// Helper function to load image as base64
const loadImageAsBase64 = (url: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        reject(new Error('Failed to get canvas context'));
        return;
      }
      
      ctx.drawImage(img, 0, 0);
      
      try {
        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
        resolve(dataUrl);
      } catch (error) {
        reject(error);
      }
    };
    
    img.onerror = () => {
      reject(new Error('Failed to load image'));
    };
    
    // Handle local images
    if (url.startsWith('/')) {
      img.src = url;
    } else {
      img.src = url;
    }
  });
};
