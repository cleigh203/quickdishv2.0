import jsPDF from 'jspdf';
import { Recipe } from '@/types/recipe';

export const generateRecipePDF = async (
  recipe: Recipe,
  userNotes?: string
): Promise<void> => {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'in',
    format: 'letter'
  });

  const pageWidth = 8.5;
  const pageHeight = 11;
  const margin = 0.75;
  const contentWidth = pageWidth - (2 * margin);
  let yPosition = margin;

  // Helper to add page break if needed
  const checkPageBreak = (neededSpace: number) => {
    if (yPosition + neededSpace > pageHeight - margin) {
      doc.addPage();
      yPosition = margin;
      return true;
    }
    return false;
  };

  // Header - QuickDish Branding
  doc.setFontSize(24);
  doc.setTextColor(255, 107, 53); // #FF6B35 - orange
  doc.text('QuickDish', margin, yPosition);
  yPosition += 0.4;

  // Recipe Title
  doc.setFontSize(20);
  doc.setTextColor(0, 0, 0);
  const titleLines = doc.splitTextToSize(recipe.name, contentWidth);
  doc.text(titleLines, margin, yPosition);
  yPosition += (titleLines.length * 0.3) + 0.3;

  // Recipe Image (if available)
  if (recipe.image) {
    try {
      checkPageBreak(2.5);
      const imgData = await loadImageAsBase64(recipe.image);
      const imgWidth = 3;
      const imgHeight = 2;
      doc.addImage(imgData, 'JPEG', margin, yPosition, imgWidth, imgHeight);
      yPosition += imgHeight + 0.3;
    } catch (error) {
      console.error('Failed to load image:', error);
    }
  }

  // Stats Section
  checkPageBreak(0.8);
  doc.setFontSize(12);
  doc.setTextColor(100, 100, 100);
  
  const stats = [
    `Servings: ${recipe.servings}`,
    `Prep: ${recipe.prepTime}`,
    `Cook: ${recipe.cookTime}`,
    `Difficulty: ${recipe.difficulty}`
  ];
  
  doc.text(stats.join(' | '), margin, yPosition);
  yPosition += 0.4;

  // Ingredients Section
  checkPageBreak(1);
  doc.setFontSize(16);
  doc.setTextColor(0, 0, 0);
  doc.text('Ingredients', margin, yPosition);
  yPosition += 0.3;

  doc.setFontSize(11);
  recipe.ingredients.forEach((ing) => {
    checkPageBreak(0.25);
    const ingredientText = `â€¢ ${ing.amount} ${ing.unit} ${ing.item}`.trim();
    const lines = doc.splitTextToSize(ingredientText, contentWidth);
    doc.text(lines, margin, yPosition);
    yPosition += lines.length * 0.2 + 0.05;
  });

  yPosition += 0.3;

  // Instructions Section
  checkPageBreak(1);
  doc.setFontSize(16);
  doc.text('Instructions', margin, yPosition);
  yPosition += 0.3;

  doc.setFontSize(11);
  recipe.instructions.forEach((instruction, index) => {
    checkPageBreak(0.4);
    const stepText = `${index + 1}. ${instruction.replace(/\[|\]/g, '')}`;
    const lines = doc.splitTextToSize(stepText, contentWidth - 0.3);
    doc.text(lines, margin + 0.3, yPosition);
    yPosition += lines.length * 0.2 + 0.15;
  });

  // Personal Notes Section (if available)
  if (userNotes) {
    yPosition += 0.2;
    checkPageBreak(1);
    doc.setFontSize(16);
    doc.text('Your Notes', margin, yPosition);
    yPosition += 0.3;

    doc.setFontSize(11);
    doc.setTextColor(80, 80, 80);
    const notesLines = doc.splitTextToSize(userNotes, contentWidth);
    notesLines.forEach((line: string) => {
      checkPageBreak(0.25);
      doc.text(line, margin, yPosition);
      yPosition += 0.2;
    });
  }

  // Footer
  const totalPages = doc.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setTextColor(150, 150, 150);
    const currentDate = new Date().toLocaleDateString();
    const footerText = `Generated by QuickDish - ${currentDate}`;
    const textWidth = doc.getTextWidth(footerText);
    doc.text(footerText, (pageWidth - textWidth) / 2, pageHeight - 0.4);
  }

  // Sanitize filename
  const sanitizeFilename = (name: string): string => {
    return name
      .replace(/[^a-z0-9]/gi, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')
      .toLowerCase();
  };

  const filename = `QuickDish-${sanitizeFilename(recipe.name)}.pdf`;
  doc.save(filename);
};

// Helper function to load image as base64
const loadImageAsBase64 = (url: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        reject(new Error('Failed to get canvas context'));
        return;
      }
      
      ctx.drawImage(img, 0, 0);
      
      try {
        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
        resolve(dataUrl);
      } catch (error) {
        reject(error);
      }
    };
    
    img.onerror = () => {
      reject(new Error('Failed to load image'));
    };
    
    // Handle local images
    if (url.startsWith('/')) {
      img.src = url;
    } else {
      img.src = url;
    }
  });
};
